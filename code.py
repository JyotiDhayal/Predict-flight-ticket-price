# -*- coding: utf-8 -*-
"""Code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VPkZQV20K3Bn5O36ml9WFkHS65F5kj3-

#Bonus Project
Topic: Predict The Flight Ticket Price  
Name: Jyoti Dhayal(Roll no: B21EE029)
"""

import pandas as pd
import numpy as np
import torch
import torch.nn as nn
from torch.autograd import Variable
from sklearn.utils import shuffle
from torchsummary import summary
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from math import sqrt
from sklearn.metrics import mean_squared_log_error
import lightgbm as lgb
import seaborn as sns
import matplotlib.pyplot as plt
from xgboost import XGBRegressor
from sklearn.ensemble import BaggingRegressor
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.metrics import mean_squared_error as mse
from sklearn.metrics import r2_score

"""##pre processing"""

data = pd.read_csv('/content/Dataset.xlsx - Sheet1.csv')
data.head()

data.shape

data.info()

data.isnull().sum()

#converting the total duration of flight from hours and minutes format to total duration in minutes format
df=data.copy()

df['Hours'] = data['Duration'].str.split(' ').str[0]
index=0
'''df['Hours'].fillna(0, inplace=True) '''
for i in df['Hours']:
  index= index+1
  if (i=='5m'):
    print(index)

duration = list(data['Duration'])
for i in range(len(duration)) :
    if len(duration[i].split()) != 2:
        if 'h' in duration[i] :
            duration[i] = duration[i].strip() + ' 0m'
        elif 'm' in duration[i] :
            duration[i] = '0h {}'.format(duration[i].strip())
dur_hours = []
dur_minutes = []
for i in range(len(duration)) :
    dur_hours.append(int(duration[i].split()[0][:-1]))
    dur_minutes.append(int(duration[i].split()[1][:-1]))
data['Duration_hours'] = dur_hours
data['Duration_minutes'] =dur_minutes
data.drop(labels = 'Duration', axis = 1, inplace = True)

data.head()

data['Duration_hours'] = data['Duration_hours'] * 60
df['Duration'] = data['Duration_hours'] + data['Duration_minutes']
df.drop(labels = 'Hours', axis = 1, inplace = True)
data['Duration']=df['Duration']
df.head()

data=data.drop(['Duration_hours','Duration_minutes'],axis=1)

#filling in null values with data from similar flights
null_columns=data.columns[data.isnull().any()]

print(data[data["Total_Stops"].isnull()][null_columns])

print(data.loc[[9039]])

data.loc[(data.Source=='Delhi') & (data.Destination=='Cochin') & (pd.DatetimeIndex(data['Date_of_Journey']).month==5)& (data.Duration==1420) &(data.Airline=='Air India') ].sort_values(['Date_of_Journey'])

data.Route=data.Route.fillna('DEL â†’ MAA â†’ COK')
data.loc[data.Total_Stops.isnull(),'Total_Stops']=1

data.isnull().sum()

data.head()

#airline vs price plot
sns.catplot(y = "Price", x = "Airline", data = data.sort_values("Price", ascending = False), kind="boxen", height = 8, aspect = 3)
plt.show()

#source vs price
sns.boxplot(y = "Price", x = "Source", data = data.sort_values("Price", ascending = False))
plt.show()

#destination vs price
sns.boxplot(y = "Price", x = "Destination", data = data.sort_values("Price", ascending = False))
plt.show()

#Plotting Bar chart for Airline vs Number of Flights
plt.figure(figsize = (30, 5))
plt.title('Count of flights based on airline')
ax=sns.countplot(x = 'Airline', data = data)
plt.xlabel('Airline')
plt.ylabel('Count of flights')
for p in ax.patches:
    ax.annotate(int(p.get_height()), (p.get_x()+0.25, p.get_height()+1), va='bottom', color= 'black')

"""##converting the airlines into different classes of tickets"""

data.columns

cols=['Airline','Source','Destination','Route','Total_Stops','Additional_Info']
for i in data[cols]:
    print("Total no of unique keys in", i, data[i].nunique())

df=data.copy()

df.head()

'''df = data[['Airline','Source','Destination','Total_Stops','Additional_Info','Date_of_Journey','Dep_Time','Route','Arrival_Time','Price']]'''

df.shape

df.Airline.unique()

cls = {'IndiGo': 'Economy','GoAir': 'Economy','Vistara': 'Economy','Vistara Premium economy': 'Premium Economy','Air Asia': 'Economy',
         'Trujet': 'Economy','Jet Airways': 'Economy','SpiceJet': 'Economy','Jet Airways Business': 'Business','Air India': 'Economy',
         'Multiple carriers': 'Economy','Multiple carriers Premium economy': 'Premium Economy'}
df['Booking_Class'] = df['Airline'].map(cls)

df=df.drop(['Airline'],axis=1)

df.shape

#plotting class with price
plt.figure(figsize = (5,4))
plt.title('Price VS Booking Class')
plt.scatter(df['Booking_Class'], df['Price'])
plt.xticks
plt.xlabel('Booking_Class')
plt.ylabel('Price of ticket')
plt.xticks(rotation = 0)

"""##calculating the number of days to departure of the flight"""

df1 = df.copy()
df1['Booking_Date'] = '1/1/2019' #data of booking the flight
df1['Booking_Date'] = pd.to_datetime(df1['Booking_Date'],format='%d/%m/%Y')
df1['Date_of_Journey'] = pd.to_datetime(df1['Date_of_Journey'],format='%d/%m/%Y')
df1['Days_to_Departure'] = (df1['Date_of_Journey'] - df1['Booking_Date']).dt.days
df['Days_to_Departure'] = df1['Days_to_Departure']
df1=df1.drop(['Booking_Date','Date_of_Journey'],axis=1)
df1.head()

df['Arrival_Time'] = data['Arrival_Time'].str.split(' ').str[0]

def get_departure(dep):
    dep = dep.split(':')
    dep = int(dep[0])
    if (dep >= 4 and dep < 12):
        return 'Morning'
    elif (dep >= 12 and dep < 18):
        return 'Noon'
    elif (dep >= 18 and dep < 20):
        return 'Evening'
    else:
        return 'Night'

df['Dep_timeofday'] = data['Dep_Time'].apply(get_departure)
df['Arr_timeofday'] = data['Arrival_Time'].apply(get_departure)

df.head()

#Plotting Bar chart for time of day for departure vs Number of Flights
plt.figure(figsize = (15, 5))
plt.title('Count of flights based on time of day for departure')
ax=sns.countplot(x = 'Dep_timeofday', data = df)
plt.xlabel('Dep_timeofday')
plt.ylabel('Count of flights')
for p in ax.patches:
    ax.annotate(int(p.get_height()), (p.get_x()+0.25, p.get_height()+1), va='bottom', color= 'black')

#Plotting Bar chart for time of day for arrival vs Number of Flights
plt.figure(figsize = (15, 5))
plt.title('Count of flights based on time of day for arrival')
ax=sns.countplot(x = 'Arr_timeofday', data = df)
plt.xlabel('Arr_timeofday')
plt.ylabel('Count of flights')
for p in ax.patches:
    ax.annotate(int(p.get_height()), (p.get_x()+0.25, p.get_height()+1), va='bottom', color= 'black')

#plotting departure time with price
plt.figure(figsize = (5,4))
plt.title('Price VS Departure Time')
plt.scatter(df['Dep_timeofday'], df['Price'])
plt.xticks
plt.xlabel('Dep_timeofday')
plt.ylabel('Price of ticket')
plt.xticks(rotation = 0)

"""##calculating the number of stops of the flight"""

df['Total_Stops'] = df['Total_Stops'].str.replace('non-stop','0')
df['Total_Stops'] = df['Total_Stops'].str.replace('stops','')
df['Total_Stops'] = df['Total_Stops'].str.replace('stop','')
df['Total_Stops'].fillna(0, inplace=True)
df['Total_Stops'] = df['Total_Stops'].astype(float)

df.head()

#plotting total stops with price
plt.figure(figsize = (5,4))
plt.title('Price VS Total Stops')
plt.scatter(df['Total_Stops'], df['Price'])
plt.xticks
plt.xlabel('Total_Stops')
plt.ylabel('Price of ticket')
plt.xticks(rotation = 0)

df.head()

df = pd.get_dummies(df, columns=['Source', 'Destination', 'Additional_Info', 'Date_of_Journey','Dep_Time', 'Arrival_Time', 'Dep_timeofday', 'Booking_Class', 'Arr_timeofday'],drop_first=True)

df.head()

"""##figuring out the route for the flights"""

def clean_route(route):
    route = str(route)
    route = route.split(' â†’ ')
    return ' '.join(route)

df['Route'] = df['Route'].apply(clean_route)


tf = TfidfVectorizer(ngram_range=(1, 1), lowercase=False)
route = tf.fit_transform(df['Route'])

route = pd.DataFrame(data = route.toarray(), columns=tf.get_feature_names())

route

df = pd.concat([df, route], axis=1)
df.drop('Route', axis=1, inplace=True)

df

"""##dividing the data into train and test sets, for implementing th emodels"""

df.shape

X = df.drop(labels=['Price'], axis=1)
y = df['Price'].values
scaler = MinMaxScaler()
scaled = scaler.fit_transform(X)
X = pd.DataFrame(scaled)
y = np.log1p(y)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1)

X_train.shape

y_train.shape

X_test.shape

y_test.shape

X_train

"""##implementing the models

Testing on different ML models:
"""

train_data = lgb.Dataset(X_train, label=y_train)
test_data = lgb.Dataset(X_test, label=y_test)

"""##1. LGBM

"""

param = {'objective': 'regression','boosting': 'gbdt','num_iterations': 3000,'learning_rate': 0.06,'num_leaves': 40,'max_depth': 24,'min_data_in_leaf':11,
         'max_bin': 4,'metric': 'l2_root'}
lgbm = lgb.train(params=param,verbose_eval=1000,train_set=train_data,valid_sets=[test_data])
y_pred1 = lgbm.predict(X_test)
print("Test Results for LGBM Regressor :")
le1 = sqrt(mean_squared_log_error(np.exp(y_test), np.exp(y_pred1)))
mse1 = sqrt(mse(y_test, y_pred1))
r2_1 = r2_score(y_test, y_pred1)
print("Mean squared error log error : ", le1)
print("Root mean squared error : ", mse1)
print("R2 Score : ", r2_1)

"""##2. XGBM"""

xgb = XGBRegressor(max_depth=9,learning_rate=0.5,n_estimators=112,silent=False,objective='reg:linear',booster='gbtree',n_jobs=1,nthread=None,
                   gamma=0,min_child_weight=1,max_delta_step=0,subsample=1,colsample_bytree=1,colsample_bylevel=1,reg_alpha=1,reg_lambda=1,
                   scale_pos_weight=1,base_score=0.5,random_state=0,seed=None)

xgb.fit(X_train, y_train)
y_pred2 = xgb.predict(X_test)
print("Test Results for XGBoost Regressor :")
le2 = sqrt(mean_squared_log_error(np.exp(y_test), np.exp(y_pred2)))
mse2 = sqrt(mse(y_test, y_pred2))
r2_2 = r2_score(y_test, y_pred2)
print("Mean squared error log error : ", le2)
print("Root mean squared error : ", mse2)
print("R2 Score : ", r2_2)

"""##3.Bagging Regressor"""

br = BaggingRegressor(base_estimator=None,n_estimators=50,max_samples=1.0,max_features=1.0,bootstrap=True,bootstrap_features=False,oob_score=False,
                      warm_start=False,n_jobs=1,random_state=1,verbose=0)
br.fit(X_train, y_train)
y_pred3 = br.predict(X_test)
print("Test Results for Bagging Regressor :")
le3 = sqrt(mean_squared_log_error(np.exp(y_test), np.exp(y_pred3)))
mse3 = sqrt(mse(y_test, y_pred3))
r2_3 = r2_score(y_test, y_pred3)
print("Mean squared error log error : ", le3)
print("Root mean squared error : ", mse3)
print("R2 Score : ", r2_3)

"""##4.Gradient Boosting Regressor"""

gb = GradientBoostingRegressor(loss='ls',learning_rate=0.3,subsample=1.0,criterion='friedman_mse',min_samples_split=30,min_samples_leaf=1,
                               min_weight_fraction_leaf=0.0,max_depth=7,min_impurity_decrease=0.0,init=None,random_state=0,max_features=None,alpha=0.9,
                               verbose=100,max_leaf_nodes=None,warm_start=False)
gb.fit(X_train, y_train)
y_pred4 = gb.predict(X_test)
print("Test Results for Gradient Boosting Regressor :")
le4 = sqrt(mean_squared_log_error(np.exp(y_test), np.exp(y_pred4)))
mse4 = sqrt(mse(y_test, y_pred4))
r2_4 = r2_score(y_test, y_pred4)
print("Mean squared error log error : ", le4)
print("Root mean squared error : ", mse4)
print("R2 Score : ", r2_4)

"""##Comparing the models"""

Models = ['LGBM Regressor','XGBoost Regressor','Bagging Regressor','Gradient Boosting Regressor' ]
mse = [mse1, mse2, mse3, mse4]
r2 = [r2_1, r2_2, r2_3, r2_4]
le = [le1, le2, le3, le4]



plt.figure(figsize = (10, 5))
plt.title('Comparing Models based on Mean Squared Error')
ax = plt.scatter(x = Models, y = mse)
plt.xlabel('Models')
plt.ylabel('MSE')
plt.plot( Models,  mse)

plt.figure(figsize = (10, 5))
plt.title('Comparing Models based on Log Mean Squared Error')
ax = plt.scatter(x = Models, y = le)
plt.xlabel('Models')
plt.ylabel('RMLSE')
plt.plot( Models,  le)

plt.figure(figsize = (10, 5))
plt.title('Comparing Models based on R2 Score')
ax = plt.scatter(x = Models, y = r2)
plt.xlabel('Models')
plt.ylabel('RMLSE')
plt.plot( Models,  r2)

Predicted_price = y_pred1*0.15 + y_pred2*0.50 + y_pred3*0.15 + y_pred4*0.20
y_pred = np.exp(Predicted_price)

prediction=pd.DataFrame(y_pred,columns=['Predicted Price'])

prediction

prediction.to_csv("predicted.csv",index=None)